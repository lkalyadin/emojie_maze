<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Emoji Maze</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@500;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Палитра пастельных тонов */
            --bg-light: #F5FAF8; 
            --card-bg: #FFFFFF;
            --primary-pink: #FECDD3; 
            --primary-pink-dark: #FB92A4;
            --primary-green: #D1E7DD; 
            --primary-green-dark: #A2C4B4;
            --primary-yellow: #FFFACD;
            --primary-yellow-dark: #FADFAD;
            --text-dark: #4B5563;
            --text-secondary: #6B7280;
            --outline: #E5E7EB;
            --star-yellow: #FFD700;
            --star-gray: #D1D5DB;
            
            --m3-state-layer-opacity: 0.08;
        }

        body, html {
            height: 100%; width: 100%; margin: 0; padding: 0;
            overflow: hidden;
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-light);
            color: var(--text-dark);
            -webkit-tap-highlight-color: transparent;
        }
        
        .screen {
            display: none; flex-direction: column; align-items: center; justify-content: center;
            width: 100%; height: 100%;
            position: absolute; top: 0; left: 0;
            box-sizing: border-box; padding: 24px;
            opacity: 0;
            transition: opacity 0.4s ease-in-out;
            visibility: hidden;
        }
        .screen.active { 
            display: flex; 
            opacity: 1; 
            visibility: visible;
        }

        .background-emojis {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            z-index: 0;
        }
        .background-emojis span {
            position: absolute;
            font-size: 3rem;
            opacity: 0;
            will-change: transform, opacity;
        }
        .background-emojis span.animated {
            animation: fadeInOut 12s infinite ease-in-out; 
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: scale(0.9); }
            50% { opacity: 0.15; transform: scale(1); }
        }
        
        /* Экран загрузки */
        #loading-screen .loader-container { position: relative; width: 150px; height: 150px; }
        #loading-screen .loader { width: 150px; height: 150px; border-radius: 50%; background: conic-gradient(var(--primary-pink) 0%, #E0E0E0 0%); }
        #loading-screen .loader-inner { width: 120px; height: 120px; background: var(--bg-light); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; color: var(--text-dark); }
        
        /* Базовый стиль панели меню */
        .menu-panel {
            background-color: var(--card-bg);
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%239C92AC' fill-opacity='0.03'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            border-radius: 28px;
            padding: 24px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 30px -5px rgba(75, 85, 99, 0.15), 0 4px 6px -2px rgba(75, 85, 99, 0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            position: relative;
            z-index: 1;
            overflow-y: auto;
            max-height: 90vh;
        }
        .panel-header {
            color: var(--text-dark);
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 16px;
            flex-shrink: 0;
        }
        
        /* Кнопки меню и карточки */
        .menu-button, .mode-card, .level-card {
            background: var(--primary-green);
            color: var(--text-dark);
            border: 2px solid transparent;
            border-radius: 16px;
            padding: 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease-out;
            font-size: 1.1rem;
            font-weight: 700;
            width: 100%;
            max-width: 380px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            box-shadow: 0 4px 15px -2px rgba(162, 196, 180, 0.4);
            position: relative;
        }
        .menu-button::after, .mode-card::after, .level-card::after { /* Слой состояния для наведения */
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--text-dark);
            opacity: 0;
            transition: opacity 0.2s ease-out;
            border-radius: inherit;
        }
        .menu-button:hover::after, .mode-card:hover::after, .level-card:hover::after {
            opacity: var(--m3-state-layer-opacity);
        }
        .menu-button:hover, .mode-card:hover, .level-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 20px -3px rgba(162, 196, 180, 0.5);
        }
        
        .nav-item.selected { 
            border-color: var(--primary-green-dark);
        }
        
        /* Главное меню */
        #main-menu-screen .main-menu-container { display: flex; flex-direction: column; align-items: center; gap: 20px; z-index: 1; }
        #main-menu-screen .sub-menu-container { display: flex; gap: 20px; }
        #play-button, #themes-button, #settings-button { background: var(--card-bg); color: var(--text-dark); border-radius: 50%; box-shadow: 0 4px 15px -2px rgba(162, 196, 180, 0.4); transition: transform 0.2s ease, box-shadow 0.2s ease; padding: 0; flex-grow: 0; border: none; display: flex; align-items: center; justify-content: center; }
        #themes-button:hover, #settings-button:hover { transform: scale(1.1); box-shadow: 0 6px 20px -2px rgba(162, 196, 180, 0.5); }
        @keyframes play-pulse { 0% { transform: scale(1.0); box-shadow: 0 4px 15px -2px rgba(162, 196, 180, 0.4); } 50% { transform: scale(1.1); box-shadow: 0 8px 25px -2px rgba(162, 196, 180, 0.6); } 100% { transform: scale(1.0); box-shadow: 0 4px 15px -2px rgba(162, 196, 180, 0.4); } }
        #play-button:hover { animation: play-pulse 1.5s infinite ease-in-out; }
        #play-button::after, #themes-button::after, #settings-button::after { display: none; }
        #play-button { width: 140px; height: 140px; }
        #themes-button, #settings-button { width: 90px; height: 90px; }
        #play-button .play-icon, #themes-button .card-icon, #settings-button .card-icon { margin: 0; }
        #play-button .play-icon { font-size: 5rem; }
        #themes-button .card-icon, #settings-button .card-icon { font-size: 3rem; }
        #main-menu-screen .nav-item.selected { box-shadow: 0 6px 20px -2px rgba(162, 196, 180, 0.8); transform: scale(1.05); border: none; }
        
        /* Счетчик звезд */
        #total-stars-counter, #total-stars-counter-levels {
            position: absolute;
            background-color: var(--card-bg);
            padding: 8px 16px;
            border-radius: 16px;
            box-shadow: 0 4px 15px -2px rgba(162, 196, 180, 0.4);
            font-size: 1.5rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 10;
        }
        #total-stars-counter {
             top: 24px;
             right: 24px;
        }
        #total-stars-counter-levels {
            top: 24px;
            right: 24px;
        }


        /* Убираем фон и заголовок с экранов выбора */
        #themes-screen .menu-panel,
        #game-mode-screen .menu-panel,
        #settings-screen .menu-panel {
            background: none;
            box-shadow: none;
        }
        #themes-screen .panel-header,
        #game-mode-screen .panel-header,
        #level-selection-screen .panel-header,
        #settings-screen .panel-header {
            display: none;
        }

        /* Делаем кнопки на экранах выбора белыми */
        #themes-screen .menu-button,
        #game-mode-screen .mode-card,
        #settings-screen .menu-button {
            background-color: var(--card-bg);
        }
         #level-selection-screen .level-card {
            background-color: var(--card-bg);
             border: 2px solid var(--outline);
        }

        #themes-screen .nav-item.selected,
        #game-mode-screen .nav-item.selected,
        #level-selection-screen .nav-item.selected,
        #settings-screen .nav-item.selected {
             border-color: var(--primary-green);
        }

        /* Экран выбора режима игры */
        .mode-card { font-size: 1.5rem; }

        /* Экран выбора уровня */
        #level-selection-screen {
            justify-content: flex-end;
            padding: 0;
            position: relative;
        }
        #level-selection-screen .back-button {
            position: absolute;
            top: 24px;
            left: 24px;
            z-index: 11;
        }
        #level-selection-screen .menu-panel {
            background: none;
            box-shadow: none;
            width: 100%;
            height: 90%;
            max-width: none;
            max-height: none;
            border-radius: 0;
            padding: 24px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        #level-selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            max-width: 550px;
            margin: 0 auto;
            gap: 16px;
            width: 100%;
            padding: 10px;
            flex-grow: 1;
            overflow-y: auto;
            box-sizing: border-box;
        }
        .level-card {
            flex-direction: column;
            aspect-ratio: 1 / 1;
            padding: 8px;
            font-size: 1.8rem;
            min-height: 80px;
        }
        .level-number {
            margin-bottom: 4px;
        }
        .level-stars {
            font-size: 0.8rem;
            height: 1em;
            line-height: 1;
        }
        .level-stars .star { color: var(--star-gray); }
        .level-stars .star.filled { color: var(--star-yellow); }

        /* Кнопки на игровом экране */
        .game-screen-icon-button { position: absolute; left: 20px; width: 56px; height: 56px; border-radius: 50%; padding: 0; font-size: 2rem; z-index: 100; border: none; background: var(--card-bg); color: var(--text-dark); box-shadow: 0 4px 15px -2px rgba(162, 196, 180, 0.4); cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; display: flex; align-items: center; justify-content: center; }
        .game-screen-icon-button:hover { transform: scale(1.1); box-shadow: 0 6px 20px -2px rgba(162, 196, 180, 0.5); }
        #return-menu-button { top: 20px; } #jump-button { top: 86px; } #restart-game-button { top: 152px; }
        #restart-game-button:hover { transform: scale(1.1) rotate(25deg); }
        
        /* Игровой экран */
        #game-screen { padding: 10px; background: var(--bg-light); }
        #game-area-wrapper { width: 100%; height: 100%; margin: 0 auto; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        #maze-wrapper { position: relative; width: 100%; flex: 1; min-height: 0; display: flex; align-items: center; justify-content: center; }
        #maze-border-emojis { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; overflow: hidden;}
        #maze-border-emojis span { position: absolute; font-size: 1.5rem; opacity: 1; }
        #maze-container { position: relative; z-index: 2; max-width: 100%; max-height: 100%; }
        #maze-canvas { border-radius: 16px; display: block; max-width: 100%; max-height: 100%; }
        
        #dpad-container { display: none; flex-direction: row; justify-content: center; align-items: center; gap: 10px; width: 100%; flex-shrink: 0; padding: 5px 0; }
        #game-screen.dpad-on #maze-wrapper { height: 90%; flex: 0 1 90%; }
        #game-screen.dpad-on #dpad-container { display: flex; height: 10%; flex: 0 0 10%; }
        .dpad-btn { width: 60px; height: 60px; background-color: var(--card-bg); color: var(--text-dark); border: none; border-radius: 50%; font-size: 2rem; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 5px rgba(0,0,0,0.2); transition: transform 0.1s ease; }
        .dpad-btn:active { transform: scale(0.95); background-color: var(--primary-green); }
        #dpad-left { order: 1; } #dpad-right { order: 2; } #dpad-down { order: 3; } #dpad-up { order: 4; }
        
        #game-ui-container { position: absolute; top: 20px; right: 20px; display: flex; flex-direction: column; align-items: flex-end; gap: 15px; z-index: 100; }
        #decor-counter { background: var(--card-bg); padding: 8px 16px; border-radius: 12px; font-size: 1.5rem; font-weight: 700; color: var(--text-dark); box-shadow: 0 4px 15px -2px rgba(162, 196, 180, 0.4); display: none; }

        /* Модальные окна */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(63, 72, 75, 0.8); display: flex; align-items: center; justify-content: center; z-index: 200; opacity: 0; transition: opacity 0.3s ease, visibility 0s 0.3s; visibility: hidden; pointer-events: none; }
        .modal-overlay.visible { opacity: 1; visibility: visible; transition: opacity 0.3s ease, visibility 0s; pointer-events: auto; }
        .modal-content { background: var(--card-bg); border: none; color: var(--text-dark); padding: 24px; border-radius: 28px; text-align: center; width: 90%; max-width: 400px; box-shadow: 0 10px 20px rgba(0,0,0,0.1); transform: scale(0.9); transition: transform 0.3s ease-out; position: relative; }
        .modal-overlay.visible .modal-content { transform: scale(1); }
        .modal-title { font-size: 2.5rem; color: var(--text-dark); margin-bottom: 8px; font-weight: 900;}
        .modal-text { font-size: 1rem; color: var(--text-secondary); }
        .animation-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none; }
        .confetti { position: absolute; width: 10px; height: 10px; background-color: #f00; opacity: 0; animation: fall 3s ease-out forwards; }
        .sad-emoji { position: absolute; font-size: 2rem; opacity: 0; animation: sad-fall 3s ease-in forwards; }
        @keyframes fall { 0% { transform: translateY(-20px) rotate(0deg); opacity: 1; } 100% { transform: translateY(150px) rotate(720deg); opacity: 0; } }
        @keyframes sad-fall { 0% { transform: translateY(-20px); opacity: 0.8; } 100% { transform: translateY(150px); opacity: 0; } }
        .modal-buttons { display: flex; justify-content: center; align-items: center; gap: 16px; margin-top: 24px; }
        .modal-buttons .menu-button { width: auto; max-width: none; }
        .emoji-button {
            font-size: 2rem;
            padding: 8px 16px !important;
            text-shadow: 0 0 4px white, 0 0 8px white;
            background: transparent !important;
            box-shadow: none !important;
            border: none !important;
        }
        .emoji-button:hover {
            transform: scale(1.1);
        }
        #victory-modal #next-level-button:not(:hover) {
             transform: scale(1.25);
        }
         #victory-modal #next-level-button:hover {
             transform: scale(1.35);
        }
        #star-rating-container { display: flex; justify-content: center; gap: 10px; margin: 16px 0; }
        .star { font-size: 2.5rem; transform: scale(0); opacity: 0; animation: popIn 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards; }
        .star.yellow { color: var(--star-yellow); } .star.gray { color: var(--star-gray); }
        .star:nth-child(2) { animation-delay: 0.2s; } .star:nth-child(3) { animation-delay: 0.4s; }
        @keyframes popIn { to { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>
    <div id="total-stars-counter">⭐ 0</div>
    <div class="background-emojis"></div>
    
    <div id="loading-screen" class="screen active">
        <div class="loader-container"><div class="loader" id="loader-progress"></div><div class="loader-inner"><span id="loader-percentage">0%</span></div></div>
    </div>

    <div id="main-menu-screen" class="screen">
        <div class="main-menu-container">
            <button id="play-button" class="menu-button nav-item" data-nav-index="0"><span class="play-icon">▶️</span></button>
            <div class="sub-menu-container">
                 <button id="themes-button" class="menu-button nav-item" data-nav-index="1"><span class="card-icon">🎨</span></button>
                 <button id="settings-button" class="menu-button nav-item" data-nav-index="2"><span class="card-icon">⚙️</span></button>
            </div>
        </div>
    </div>

    <div id="game-mode-screen" class="screen">
        <button class="game-screen-icon-button back-button nav-item" data-nav-index="0" data-target-screen="main-menu-screen">🏠</button>
        <div class="menu-panel">
            <div class="panel-header" data-lang="select_mode">Выберите режим</div>
            <button id="mode-classic" class="mode-card nav-item" data-nav-index="1" data-mode="classic">
                <span class="card-icon">🗺️</span> <span data-lang="classic">Классический</span>
            </button>
            <button id="mode-flashlight" class="mode-card nav-item" data-nav-index="2" data-mode="flashlight">
                <span class="card-icon">🔦</span> <span data-lang="flashlight">Фонарик</span>
            </button>
            <button id="mode-ghost" class="mode-card nav-item" data-nav-index="3" data-mode="ghost">
                <span class="card-icon">👻</span> <span data-lang="ghost">Привидение</span>
            </button>
        </div>
    </div>

    <div id="level-selection-screen" class="screen">
        <button class="game-screen-icon-button back-button" data-target-screen="game-mode-screen">⬅️</button>
        <div id="total-stars-counter-levels">⭐ 0</div>
        <div class="menu-panel">
            <div id="level-selection-grid"></div>
        </div>
    </div>

    <div id="settings-screen" class="screen">
        <button class="game-screen-icon-button back-button nav-item" data-nav-index="0" data-target-screen="main-menu-screen">🏠</button>
        <div class="menu-panel">
            <div class="panel-header" data-lang="settings">Настройки</div>
            <button id="dpad-toggle-button" class="menu-button nav-item" data-nav-index="1">🕹️ <span data-lang="dpad_off"></span></button>
            <button id="sound-toggle-button" class="menu-button nav-item" data-nav-index="2">🔊 <span data-lang="sound_on"></span></button>
            <button id="language-button" class="menu-button nav-item" data-nav-index="3"><span class="card-icon">🌐</span><span></span></button>
            <button id="reset-progress-button" class="menu-button nav-item" data-nav-index="4" style="background-color: var(--primary-pink);"><span data-lang="reset_progress"></span></button>
        </div>
    </div>
    
    <div id="themes-screen" class="screen">
         <button class="game-screen-icon-button back-button nav-item" data-nav-index="0" data-target-screen="main-menu-screen">🏠</button>
        <div class="menu-panel">
             <div class="panel-header" data-lang="themes">Темы</div>
             <button id="random-theme-button" class="menu-button nav-item" data-nav-index="1" data-theme-key="random" tabindex="0"><span data-lang="random_theme"></span></button>
        </div>
    </div>

    <div id="game-screen" class="screen">
        <button id="return-menu-button" class="game-screen-icon-button">🏠</button>
        <button id="jump-button" class="game-screen-icon-button">💡</button>
        <button id="restart-game-button" class="game-screen-icon-button">🔄</button>
        
        <div id="game-ui-container">
            <div id="decor-counter"></div>
        </div>
        
        <div id="game-area-wrapper">
            <div id="maze-wrapper">
                 <div id="maze-border-emojis"></div>
                 <div id="maze-container"><canvas id="maze-canvas"></canvas></div>
            </div>
             <div id="dpad-container">
                <button id="dpad-left" class="dpad-btn">⬅️</button>
                <button id="dpad-right" class="dpad-btn">➡️</button>
                <button id="dpad-down" class="dpad-btn">⬇️</button>
                <button id="dpad-up" class="dpad-btn">⬆️</button>
            </div>
        </div>
    </div>
    
    <div id="victory-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="animation-container"></div>
            <h1 class="modal-title">🎉</h1>
            <div id="star-rating-container"></div>
            <div class="modal-buttons">
                <button id="menu-button-victory" class="menu-button emoji-button">🏠</button>
                <button id="next-level-button" class="menu-button emoji-button">▶️</button>
                <button id="retry-level-button-victory" class="menu-button emoji-button">🔄</button>
            </div>
        </div>
    </div>
    
    <div id="confirm-exit-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="modal-title" data-lang="confirm_exit_title"></h2>
            <p class="modal-text" data-lang="confirm_exit_text"></p>
            <div class="modal-buttons">
                <button id="confirm-exit-no" class="menu-button emoji-button">❌</button>
                <button id="confirm-exit-yes" class="menu-button emoji-button">✅</button>
            </div>
        </div>
    </div>

    <div id="confirm-reset-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="modal-title" data-lang="confirm_reset_title"></h2>
            <p class="modal-text" data-lang="confirm_reset_text"></p>
            <div class="modal-buttons">
                <button id="confirm-reset-no" class="menu-button emoji-button">❌</button>
                <button id="confirm-reset-yes" class="menu-button emoji-button">✅</button>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const config = {
            backgrounds: [
                { src: 'https://lkalyadin.github.io/emojie_maze/images/abstract-design-element-shape-yellow-3472.png', wallColor: '#FFB703' },
                { src: 'https://lkalyadin.github.io/emojie_maze/images/abstract-design-element-blue-purple-3588.png', wallColor: '#D9ABFF' },
                { src: 'https://lkalyadin.github.io/emojie_maze/images/abstract-design-element-pink-3599.png', wallColor: '#FF4D6D' },
                { src: 'https://lkalyadin.github.io/emojie_maze/images/abstract-design-element-purple-3569.png', wallColor: '#A06CD5' },
                { src: 'https://lkalyadin.github.io/emojie_maze/images/abstract-design-element-purple-3557.png', wallColor: '#B392AC' },
                { src: 'https://lkalyadin.github.io/emojie_maze/images/abstract-design-element-purple-3560.png', wallColor: '#8367C7' }
            ],
            levels: [
                { h: 4,  w: 4,  bonuses: 0, visibility: { h: 2, w: 2 } }, { h: 4,  w: 5,  bonuses: 0, visibility: { h: 2, w: 2 } },
                { h: 5,  w: 5,  bonuses: 0, visibility: { h: 2, w: 2 } }, { h: 6,  w: 5,  bonuses: 2, visibility: { h: 3, w: 3 } },
                { h: 6,  w: 6,  bonuses: 2, visibility: { h: 3, w: 3 } }, { h: 7,  w: 6,  bonuses: 3, visibility: { h: 3, w: 3 } },
                { h: 7,  w: 7,  bonuses: 3, visibility: { h: 3, w: 3 } }, { h: 8,  w: 7,  bonuses: 3, visibility: { h: 4, w: 4 } },
                { h: 8,  w: 8,  bonuses: 4, visibility: { h: 4, w: 4 } }, { h: 8,  w: 9,  bonuses: 4, visibility: { h: 4, w: 4 } },
                { h: 9,  w: 9,  bonuses: 4, visibility: { h: 4, w: 4 } }, { h: 10, w: 9,  bonuses: 5, visibility: { h: 5, w: 5 } },
                { h: 10, w: 10, bonuses: 5, visibility: { h: 5, w: 5 } }, { h: 10, w: 11, bonuses: 5, visibility: { h: 5, w: 5 } },
                { h: 11, w: 11, bonuses: 5, visibility: { h: 5, w: 5 } }, { h: 12, w: 11, bonuses: 6, visibility: { h: 6, w: 6 } },
                { h: 12, w: 12, bonuses: 6, visibility: { h: 6, w: 6 } }, { h: 12, w: 13, bonuses: 6, visibility: { h: 6, w: 6 } },
                { h: 13, w: 13, bonuses: 6, visibility: { h: 6, w: 6 } }, { h: 14, w: 14, bonuses: 7, visibility: { h: 7, w: 7 } },
                { h: 12, w: 14, bonuses: 8, visibility: { h: 6, w: 6 } }, { h: 14, w: 12, bonuses: 8, visibility: { h: 6, w: 6 } },
                { h: 13, w: 15, bonuses: 8, visibility: { h: 6, w: 6 } }, { h: 15, w: 13, bonuses: 8, visibility: { h: 6, w: 6 } },
                { h: 15, w: 15, bonuses: 7, visibility: { h: 7, w: 7 } }
            ],
            themes: {
                jungle: { name: 'Джунгли', player: '🐒', finish: '🍌', walls: ['🌳', '🍃', '🌴', '🌸'], decor: ['🌺', '🦋'], gradient: ['#D4F0C4', '#A0D8A0']},
                antarctica: { name: 'Антарктика', player: '🐧', finish: '❤️', walls: ['❄️', '🧊'], decor: ['🧊', '❄️'], gradient: ['#E6F3FB', '#B0C4DE']},
                catsAndMice: { name: 'Кошки-мышки', player: '🐱', finish: '🐭', walls: ['🌲', '🏠', '🌿', '🐾'], decor: ['🧶', '🧀'], gradient: ['#FFFACD', '#F5DEB3']},
                snail: { name: 'Улитка', player: '🐌', finish: '🥬', walls: ['🌲', '🌸', '🍄', '💧'], decor: ['🐞', '🌼'], gradient: ['#DFF0D8', '#BDECB6']},
                football: { name: 'Футбол', player: '⚽', finish: '🥅', walls: ['📣', '🏆', '👟'], decor: ['🏟️', '🏅'], gradient: ['#D9EAD3', '#B6D7A8']},
                sea: { name: 'Море', player: '🐬', finish: '⭐', walls: ['🌊', '⛵', '🏝️', '🏖️'], decor: ['🐠', '🦀', '🐚'], gradient: ['#B2EBF2', '#81D4FA']},
            },
            audio: {
                menu: 'https://lkalyadin.github.io/emojie_maze/audio/light.mp3',
                game: [ 'https://lkalyadin.github.io/emojie_maze/audio/kinderszenen.mp3', 'https://lkalyadin.github.io/emojie_maze/audio/etude8.mp3', 'https://lkalyadin.github.io/emojie_maze/audio/dogsandcats.mp3', 'https://lkalyadin.github.io/emojie_maze/audio/theskaterswaltz.mp3' ],
                victorySfx: ['https://lkalyadin.github.io/emojie_maze/audio/sfx-piano-bar2.mp3', 'https://lkalyadin.github.io/emojie_maze/audio/sfx-sfx-strings7.mp3'],
                collectSfx: 'https://lkalyadin.github.io/emojie_maze/audio/sfx-magic15.mp3',
                defeatSfx: 'https://lkalyadin.github.io/emojie_maze/audio/sfx-mouth10.mp3',
            },
            languageNames: {
                ru: 'Русский',
                en: 'English'
            },
            languages: {
                ru: {
                    settings: 'Настройки', themes: 'Темы', random_theme: 'Случайная тема', 
                    classic: 'Классический', flashlight: 'Фонарик', ghost: 'Привидение',
                    menu: 'Меню', retry: 'Повторить', next_level: 'Следующий',
                    dpad_on: 'D-pad Вкл', dpad_off: 'D-pad Выкл', 
                    sound_on: 'Звук Вкл', sound_off: 'Звук Выкл',
                    confirm_exit_title: 'Вернуться в меню?', confirm_exit_text: 'Прогресс уровня не будет сохранен.',
                    select_mode: 'Выберите режим', reset_progress: 'Сбросить прогресс',
                    confirm_reset_title: 'Сбросить прогресс?', confirm_reset_text: 'Все ваши звезды будут удалены. Это действие необратимо.'
                },
                en: {
                    settings: 'Settings', themes: 'Themes', random_theme: 'Random Theme', 
                    classic: 'Classic', flashlight: 'Flashlight', ghost: 'Ghost',
                    menu: 'Menu', retry: 'Retry', next_level: 'Next Level',
                    dpad_on: 'D-pad On', dpad_off: 'D-pad Off', 
                    sound_on: 'Sound On', sound_off: 'Sound Off',
                    confirm_exit_title: 'Return to menu?', confirm_exit_text: 'Level progress will be lost.',
                    select_mode: 'Select Mode', reset_progress: 'Reset Progress',
                    confirm_reset_title: 'Reset progress?', confirm_reset_text: 'All your stars will be deleted. This action is irreversible.'
                }
            }
        };

        const state = {
            currentScreen: 'loading-screen',
            settings: { dpad: false, sound: true, language: 'en' },
            progress: { classic: {}, flashlight: {}, ghost: {} },
            theme: 'random', 
            gameMode: 'classic',
            currentLevel: 0,
            mazeWidth: 4,
            mazeHeight: 4,
            isGameActive: false, 
            isAnimating: false,
            playerIsDefeated: false,
            defeatAnimation: { progress: 0, bubbles: [] },
            currentNavIndex: 0, navigableItems: [],
            playerPos: {x: 0, y: 0},
            startPos: {x: 0, y: 0},
            finishPos: {x: 0, y: 0},
            ghostPos: {x: 0, y: 0},
            playerStepCount: 0,
            jumpState: { active: false, progress: 0 },
            jumpAnim: { yOffset: 0, scale: 1 },
            totalDecor: 0,
            collectedDecor: 0,
            wallColor: '#FFFFFF', 
        };
        
        const audioManager = {
            currentTrack: null, musicWasPlaying: false,
            play(trackUrl, loop = false) { if (!state.settings.sound) return; const trackName = trackUrl.split('/').pop(); if (this.currentTrack && this.currentTrack.src.endsWith(trackName)) { if(this.currentTrack.paused) this.currentTrack.play().catch(e => {}); return; } this.stop(); this.currentTrack = new Audio(trackUrl); this.currentTrack.loop = loop; const playPromise = this.currentTrack.play(); if (playPromise !== undefined) { playPromise.catch(() => { const startAudio = () => { if (state.settings.sound) this.currentTrack?.play().catch(e=>{}); }; window.addEventListener('click', startAudio, { once: true }); }); } },
            stop() { if (this.currentTrack) { this.currentTrack.pause(); this.currentTrack.onended = null; this.currentTrack.src = ''; this.currentTrack = null; } },
            playSfx(trackUrl) { if (!state.settings.sound) return; const sfx = new Audio(trackUrl); sfx.play().catch(e => {}); },
            playGameMusic() { this.stop(); let playlist = [...config.audio.game]; const playNext = () => { if (!state.settings.sound || state.currentScreen !== 'game-screen') return; if (playlist.length === 0) playlist = [...config.audio.game]; const track = playlist.splice(Math.floor(Math.random() * playlist.length), 1)[0]; this.play(track, false); if(this.currentTrack) this.currentTrack.onended = playNext; }; playNext(); },
            handleVisibility() { if (document.hidden) { this.musicWasPlaying = this.currentTrack && !this.currentTrack.paused; this.currentTrack?.pause(); } else if (this.musicWasPlaying) { this.currentTrack?.play().catch(e => {}); } }
        };

        const victoryModal = document.getElementById('victory-modal');
        const confirmExitModal = document.getElementById('confirm-exit-modal');
        const confirmResetModal = document.getElementById('confirm-reset-modal');
        const mazeCanvas = document.getElementById('maze-canvas');
        const mazeCtx = mazeCanvas.getContext('2d');
        const totalStarsCounter = document.getElementById('total-stars-counter');
        const backgroundEmojis = document.querySelector('.background-emojis');

        let mazeGrid, initialMazeGrid, currentTheme, cellSize, currentBgImage;
        let hintScreenActive = false, touchStartX, touchStartY;
        let animationFrameId;
        let displayPos = { x: 0, y: 0 }, targetPos = { x: 0, y: 0 };
        const ANIMATION_SPEED = 0.4;
        let moveInterval = null;

        function saveProgress() {
            try {
                localStorage.setItem('emojiMazeProgress', JSON.stringify(state.progress));
            } catch (e) {
                console.error("Failed to save progress:", e);
            }
        }
        
        function loadProgress() {
            try {
                const savedProgress = localStorage.getItem('emojiMazeProgress');
                if (savedProgress) {
                    const parsed = JSON.parse(savedProgress);
                    if(parsed.classic && parsed.flashlight && parsed.ghost) {
                       state.progress = parsed;
                    }
                }
            } catch (e) {
                console.error("Failed to load progress:", e);
                state.progress = { classic: {}, flashlight: {}, ghost: {} };
            }
        }

        function updateTotalStarsCounter() {
            const classicStars = Object.values(state.progress.classic).reduce((sum, stars) => sum + stars, 0);
            const flashlightStars = Object.values(state.progress.flashlight).reduce((sum, stars) => sum + stars, 0);
            const ghostStars = Object.values(state.progress.ghost || {}).reduce((sum, stars) => sum + stars, 0);
            const totalStars = classicStars + flashlightStars + ghostStars;
            const counterText = `⭐ ${totalStars}`;
            totalStarsCounter.innerHTML = counterText;
            const levelScreenCounter = document.getElementById('total-stars-counter-levels');
            if (levelScreenCounter) {
                levelScreenCounter.innerHTML = counterText;
            }
        }

        function resetProgress() {
            state.progress = { classic: {}, flashlight: {}, ghost: {} };
            saveProgress();
            updateTotalStarsCounter();
            if (state.currentScreen === 'level-selection-screen') {
                showLevelSelectionScreen(state.gameMode);
            }
        }

        function switchScreen(screenId) {
            if(animationFrameId) stopGameLoop();
            const currentScreenEl = document.getElementById(state.currentScreen);
            const nextScreenEl = document.getElementById(screenId);
            if (currentScreenEl) currentScreenEl.classList.remove('active');
            if (nextScreenEl) nextScreenEl.classList.add('active');
            state.currentScreen = screenId;
            
            const mainCounter = document.getElementById('total-stars-counter');
            const levelCounter = document.getElementById('total-stars-counter-levels');
            
            if (screenId === 'level-selection-screen') {
                mainCounter.style.display = 'none';
                levelCounter.style.display = 'flex';
            } else {
                 mainCounter.style.display = screenId === 'game-screen' ? 'none' : 'flex';
                 levelCounter.style.display = 'none';
            }
            
            if (screenId === 'main-menu-screen') {
                updateTotalStarsCounter();
            }

            document.getElementById('game-screen').classList.toggle('dpad-on', screenId === 'game-screen' && state.settings.dpad);

            setupNavigation();
            
            if (screenId === 'game-screen') {
                audioManager.playGameMusic();
            } else {
                audioManager.play(config.audio.menu, true);
            }
        }
        
        function setupNavigation() {
            const activeScreen = document.getElementById(state.currentScreen);
            if (!activeScreen) return;
            state.navigableItems = Array.from(activeScreen.querySelectorAll('.nav-item:not(.disabled)'));
            state.navigableItems.sort((a, b) => (parseInt(a.dataset.navIndex || 0)) - (parseInt(b.dataset.navIndex || 0)));

            if(state.navigableItems.length > 0) {
                 state.currentNavIndex = 0;
            }
            updateNavSelection();
        }

        function updateNavSelection() {
            state.navigableItems.forEach((item, index) => {
                item.classList.toggle('selected', index === state.currentNavIndex);
            });
        }
        
        function handleGlobalKeyDown(e) {
            if (hintScreenActive || state.playerIsDefeated) { beginGameplay(e); e.preventDefault(); return; }
            if (state.currentScreen === 'game-screen' && !confirmExitModal.classList.contains('visible') && !victoryModal.classList.contains('visible')) {
                if (e.key === 'Escape') { showModal(confirmExitModal); state.isGameActive = false; } else handleGameInput(e);
                return;
            }
            if (victoryModal.classList.contains('visible') || confirmExitModal.classList.contains('visible') || confirmResetModal.classList.contains('visible')) return;
            if (!state.navigableItems.length) return;

            let handled = false;
            switch (e.key) {
                case 'ArrowDown': 
                    state.currentNavIndex = (state.currentNavIndex + 1) % state.navigableItems.length; 
                    handled = true; 
                    break;
                case 'ArrowUp': 
                    state.currentNavIndex = (state.currentNavIndex - 1 + state.navigableItems.length) % state.navigableItems.length; 
                    handled = true; 
                    break;
                case 'ArrowRight':
                    if (state.currentScreen === 'level-selection-screen') {
                        state.currentNavIndex = Math.min(state.currentNavIndex + 1, state.navigableItems.length - 1);
                    } else {
                         state.currentNavIndex = (state.currentNavIndex + 1) % state.navigableItems.length; 
                    }
                    handled = true;
                    break;
                case 'ArrowLeft':
                    if (state.currentScreen === 'level-selection-screen') {
                        state.currentNavIndex = Math.max(state.currentNavIndex - 1, 0);
                    } else {
                         state.currentNavIndex = (state.currentNavIndex - 1 + state.navigableItems.length) % state.navigableItems.length; 
                    }
                    handled = true;
                    break;
                case 'Enter': 
                    if (state.navigableItems[state.currentNavIndex]) {
                        state.navigableItems[state.currentNavIndex].click();
                         handled = true; 
                    }
                    break;
                case 'Escape': document.querySelector(`#${state.currentScreen} .back-button`)?.click(); handled = true; break;
            }
            if (handled) { e.preventDefault(); updateNavSelection(); }
        }

        function updateEmojiBackground() {
            let themeConfig = config.themes[state.theme];
            let emojis = [];
            if (!themeConfig || state.theme === 'random') {
                Object.values(config.themes).forEach(t => emojis.push(...t.walls));
            } else {
                emojis.push(...themeConfig.walls);
            }
            
            backgroundEmojis.innerHTML = '';
            for (let i = 0; i < 60; i++) {
                const emoji = document.createElement('span');
                emoji.textContent = emojis[Math.floor(Math.random() * emojis.length)] || '✨';
                emoji.style.left = `${Math.random() * 100}vw`;
                emoji.style.top = `${Math.random() * 100}vh`;
                if (i < 20) {
                    emoji.style.opacity = '0.15';
                } else {
                    emoji.classList.add('animated');
                    emoji.style.animationDelay = `${Math.random() * 12}s`;
                }
                backgroundEmojis.appendChild(emoji);
            }
        }
        
        function generateMaze(width, height, startCell) { 
            let grid = Array.from({ length: height }, (_, y) => Array.from({ length: width }, (_, x) => ({ x, y, walls: { top: true, right: true, bottom: true, left: true }, visited: false, decor: null })));
            let stack = [grid[startCell.y][startCell.x]];
            grid[startCell.y][startCell.x].visited = true;

            while (stack.length > 0) {
                let current = stack.pop();
                let neighbors = [];
                const {x, y} = current;
                if (y > 0 && !grid[y - 1][x].visited) neighbors.push(grid[y - 1][x]);
                if (x < width - 1 && !grid[y][x + 1].visited) neighbors.push(grid[y][x + 1]);
                if (y < height - 1 && !grid[y + 1][x].visited) neighbors.push(grid[y + 1][x]);
                if (x > 0 && !grid[y][x - 1].visited) neighbors.push(grid[y][x - 1]);
                if (neighbors.length > 0) {
                    stack.push(current);
                    let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    if (next.y < current.y) { current.walls.top = false; next.walls.bottom = false; }
                    else if (next.x > current.x) { current.walls.right = false; next.walls.left = false; }
                    else if (next.y > current.y) { current.walls.bottom = false; next.walls.top = false; }
                    else if (next.x < current.x) { current.walls.left = false; next.walls.right = false; }
                    next.visited = true;
                    stack.push(next);
                }
            }
            return grid;
        }
        
        function findLongestPath(grid, start) {
            const queue = [[start, 0]];
            const visited = new Set([`${start.x},${start.y}`]);
            let maxDist = 0;
            let farthestCell = start;

            while(queue.length > 0) {
                const [current, dist] = queue.shift();
                
                if (dist > maxDist) {
                    maxDist = dist;
                    farthestCell = current;
                }

                const {x, y} = current;
                const cell = grid[y][x];
                const neighbors = [];
                if (!cell.walls.top && grid[y-1]?.[x]) neighbors.push(grid[y-1][x]);
                if (!cell.walls.right && grid[y]?.[x+1]) neighbors.push(grid[y][x+1]);
                if (!cell.walls.bottom && grid[y+1]?.[x]) neighbors.push(grid[y+1][x]);
                if (!cell.walls.left && grid[y]?.[x-1]) neighbors.push(grid[y][x-1]);
                
                for(const neighbor of neighbors) {
                     if(neighbor) {
                        const key = `${neighbor.x},${neighbor.y}`;
                        if(!visited.has(key)) {
                            visited.add(key);
                            queue.push([neighbor, dist + 1]);
                        }
                    }
                }
            }
            return farthestCell;
        }
        
        function findSolutionPath(grid, start, end) {
            const queue = [[start]];
            const visited = new Set([`${start.x},${start.y}`]);

            while(queue.length > 0) {
                const path = queue.shift();
                const {x, y} = path[path.length - 1];

                if (x === end.x && y === end.y) return path;

                const cell = grid[y][x];
                const neighbors = [];
                if (!cell.walls.top && grid[y-1]?.[x]) neighbors.push(grid[y-1][x]);
                if (!cell.walls.right && grid[y]?.[x+1]) neighbors.push(grid[y][x+1]);
                if (!cell.walls.bottom && grid[y+1]?.[x]) neighbors.push(grid[y+1][x]);
                if (!cell.walls.left && grid[y]?.[x-1]) neighbors.push(grid[y][x-1]);
                
                for(const neighbor of neighbors) {
                    const key = `${neighbor.x},${neighbor.y}`;
                    if(!visited.has(key)) {
                        visited.add(key);
                        const newPath = [...path, neighbor];
                        queue.push(newPath);
                    }
                }
            }
            return [];
        }

        function addDecorations(grid, start, end, decorCount) {
            if (!currentTheme.decor || currentTheme.decor.length === 0) {
                state.totalDecor = 0;
                return;
            };

            const solutionPath = findSolutionPath(grid, start, end);
            const solutionSet = new Set(solutionPath.map(p => `${p.x},${p.y}`));

            const availableCells = [];
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[0].length; x++) {
                     const wallCount = Object.values(grid[y][x].walls).filter(Boolean).length;
                    if (!solutionSet.has(`${x},${y}`) && wallCount >= 3) {
                        availableCells.push(grid[y][x]);
                    }
                }
            }
            
            state.totalDecor = Math.min(decorCount, availableCells.length);

            for (let i = 0; i < state.totalDecor; i++) {
                const randIndex = Math.floor(Math.random() * availableCells.length);
                const cellToDecorate = availableCells.splice(randIndex, 1)[0];
                if (cellToDecorate) {
                    cellToDecorate.decor = currentTheme.decor[Math.floor(Math.random() * currentTheme.decor.length)];
                }
            }
        }

        function drawWavyLine(ctx, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            const amplitude = 2; 
            const wavelength = 15; 

            ctx.save();
            ctx.translate(x1, y1);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            for (let i = 0; i < len; i++) {
                ctx.lineTo(i, Math.sin(i / wavelength * Math.PI) * amplitude);
            }
            ctx.stroke();
            ctx.restore();
        }

        function drawWalls() {
            mazeCtx.strokeStyle = state.wallColor;
            mazeCtx.lineWidth = Math.max(2, Math.min(6, Math.floor(cellSize * 0.1)));
            mazeCtx.lineCap = 'round';
            
            mazeCtx.beginPath();
            mazeCtx.moveTo(0,0);
            mazeCtx.lineTo(state.mazeWidth * cellSize, 0);
            mazeCtx.lineTo(state.mazeWidth * cellSize, state.mazeHeight * cellSize);
            mazeCtx.lineTo(0, state.mazeHeight * cellSize);
            mazeCtx.closePath();
            mazeCtx.stroke();

            for (let y = 0; y < state.mazeHeight; y++) {
                for (let x = 0; x < state.mazeWidth; x++) {
                    const cell = mazeGrid[y][x];
                    const startX = x * cellSize, startY = y * cellSize;
                    if (cell.walls.bottom && y < state.mazeHeight - 1) {
                        drawWavyLine(mazeCtx, startX, startY + cellSize, startX + cellSize, startY + cellSize);
                    }
                    if (cell.walls.right && x < state.mazeWidth - 1) {
                        drawWavyLine(mazeCtx, startX + cellSize, startY, startX + cellSize, startY + cellSize);
                    }
                }
            }
        }
        
        function drawDecor() {
            mazeCtx.textAlign = 'center';
            mazeCtx.textBaseline = 'middle';
            for (let y = 0; y < state.mazeHeight; y++) {
                for (let x = 0; x < state.mazeWidth; x++) {
                     const cell = mazeGrid[y][x];
                    if (cell.decor) {
                        const startX = x * cellSize, startY = y * cellSize;
                        mazeCtx.font = `bold ${cellSize * 0.6}px sans-serif`;
                        mazeCtx.fillText(cell.decor, startX + cellSize / 2, startY + cellSize / 2 + (cellSize*0.05));
                    }
                }
            }
        }

        function drawPlayer(yOffset = 0, scale = 1) {
            mazeCtx.save();
            const playerSize = Math.floor(cellSize * 0.7);
            mazeCtx.font = `bold ${playerSize}px sans-serif`;
            
            let rotation = 0;
            let baseScaleX = 1, baseScaleY = 1;

            if(state.isAnimating) {
                if (currentTheme.player === '⚽') {
                    rotation = (Date.now() / 250); 
                } else if (currentTheme.player === '🐌') {
                    baseScaleX = 1 + Math.sin(Date.now() * 0.015) * 0.1;
                    baseScaleY = 1 - Math.sin(Date.now() * 0.015) * 0.1;
                } else {
                    rotation = Math.sin(Date.now() * 0.02) * 0.2;
                }
            }
            
            mazeCtx.translate(displayPos.x, displayPos.y + yOffset);
            mazeCtx.rotate(rotation);
            mazeCtx.scale(baseScaleX * scale, baseScaleY * scale);
            mazeCtx.textAlign = 'center';
            mazeCtx.textBaseline = 'middle';
            mazeCtx.fillText(currentTheme.player, 0, 0 + (cellSize * 0.05));
            mazeCtx.restore();
        }

        function drawFinish(yOffset = 0, scale = 1) {
            mazeCtx.save();
            const finishSize = Math.floor(cellSize * 0.8);
            mazeCtx.font = `bold ${finishSize}px sans-serif`;
            
            mazeCtx.translate(state.finishPos.x * cellSize + cellSize / 2, state.finishPos.y * cellSize + cellSize / 2 + yOffset);
            mazeCtx.scale(scale, scale);
            mazeCtx.textAlign = 'center';
            mazeCtx.textBaseline = 'middle';
            mazeCtx.fillText(currentTheme.finish, 0, 0 + (cellSize * 0.05));
            mazeCtx.restore();
        }

        function drawGhost() {
            mazeCtx.save();
            const ghostSize = Math.floor(cellSize * 0.8);
            mazeCtx.font = `bold ${ghostSize}px sans-serif`;
            mazeCtx.textAlign = 'center';
            mazeCtx.textBaseline = 'middle';
            const x = state.ghostPos.x * cellSize + cellSize / 2;
            const y = state.ghostPos.y * cellSize + cellSize / 2;
            const yBob = Math.sin(Date.now() * 0.005) * (cellSize * 0.1);
            mazeCtx.fillText('👻', x, y + yBob);
            mazeCtx.restore();
        }
        
        function drawPlayerDefeatAnimation() {
            state.defeatAnimation.progress += 0.02;

            const bubbles = state.defeatAnimation.bubbles;
            mazeCtx.save();
            mazeCtx.translate(displayPos.x, displayPos.y);

            for(const bubble of bubbles) {
                bubble.radius += bubble.speed;
                bubble.opacity = 1 - (bubble.radius / bubble.maxRadius);
                if (bubble.opacity < 0) bubble.opacity = 0;

                mazeCtx.beginPath();
                mazeCtx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                mazeCtx.fillStyle = `rgba(225, 239, 255, ${bubble.opacity})`;
                mazeCtx.fill();
            }
            mazeCtx.restore();

            if (state.defeatAnimation.progress >= 1) {
                state.playerIsDefeated = false; 
                restartLevel();
            }
        }

        function gameLoop() {
            if (state.currentScreen !== 'game-screen') return;

            if (!state.playerIsDefeated && state.jumpState.active) {
                state.jumpState.progress += 0.04; 
                if (state.jumpState.progress >= 1) {
                    state.jumpState.active = false;
                    state.jumpState.progress = 0;
                    state.jumpAnim = { yOffset: 0, scale: 1 }; 
                } else {
                    const p = state.jumpState.progress;
                    state.jumpAnim.yOffset = -4 * (p - p * p) * (cellSize * 0.4); 
                    state.jumpAnim.scale = 1 + Math.sin(p * Math.PI) * 0.2;
                }
            }
            
            if (!state.playerIsDefeated) {
                displayPos.x += (targetPos.x - displayPos.x) * ANIMATION_SPEED;
                displayPos.y += (targetPos.y - displayPos.y) * ANIMATION_SPEED;
                const dx = targetPos.x - displayPos.x; const dy = targetPos.y - displayPos.y;
                if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) {
                    displayPos.x = targetPos.x; displayPos.y = targetPos.y;
                    if (state.isAnimating) { 
                        state.isAnimating = false; 
                        checkWin() || (state.gameMode === 'ghost' && checkCollision());
                    }
                }
            }
            
            // --- START DRAWING ---
            mazeCtx.clearRect(0, 0, mazeCanvas.width, mazeCanvas.height);
            
            if (currentBgImage && currentBgImage.complete) {
                mazeCtx.drawImage(currentBgImage, 0, 0, mazeCanvas.width, mazeCanvas.height);
            } else {
                const gradient = mazeCtx.createLinearGradient(0, 0, 0, mazeCanvas.height);
                gradient.addColorStop(0, currentTheme.gradient[0]);
                gradient.addColorStop(1, currentTheme.gradient[1]);
                mazeCtx.fillStyle = gradient;
                mazeCtx.fillRect(0, 0, mazeCanvas.width, mazeCanvas.height);
            }

            drawWalls();

            const yOffset = state.jumpAnim.yOffset;
            const scale = state.jumpAnim.scale;
            
            drawDecor();
            drawFinish(yOffset, scale);

            if (state.gameMode === 'ghost') {
                drawGhost();
            }

            if (state.playerIsDefeated) {
                drawPlayerDefeatAnimation();
            } else {
                drawPlayer(yOffset, scale);
            }

            if (state.isGameActive && state.gameMode === 'flashlight') {
                const lightRadius = ((config.levels[state.currentLevel].visibility.w + config.levels[state.currentLevel].visibility.h) / 2) * cellSize;
                
                mazeCtx.save();
                mazeCtx.fillStyle = 'black';
                mazeCtx.beginPath();
                mazeCtx.rect(0, 0, mazeCanvas.width, mazeCanvas.height);
                mazeCtx.arc(displayPos.x, displayPos.y, lightRadius, 0, Math.PI * 2, true);
                mazeCtx.fill('evenodd');
                mazeCtx.restore();
            }
            // --- END DRAWING ---

            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        function stopGameLoop() { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } }
        
        function updateDecorCounter() {
            if (state.totalDecor > 0 && currentTheme.decor.length > 0) {
                const decorCounterEl = document.getElementById('decor-counter');
                decorCounterEl.style.display = 'block';
                const decorEmoji = currentTheme.decor[0] || '⭐';
                decorCounterEl.innerHTML = `${decorEmoji}&nbsp;${state.collectedDecor}&nbsp;/&nbsp;${state.totalDecor}`;
            } else {
                document.getElementById('decor-counter').style.display = 'none';
            }
        }

        function restartLevel() {
            hideModal(victoryModal);
            startGame(state.currentLevel);
        }

        function handleGameInput(e) {
            if (state.isAnimating || !state.isGameActive || state.playerIsDefeated) return;
             if (e.key === 'Enter' || (e.type === 'touchstart' && e.touches.length > 1) ) {
                if (!state.jumpState.active) { state.jumpState.active = true; }
                return;
            }

            let key;
            if(e.key) { key = e.key; } else { key = e; }

            let { x, y } = state.playerPos; const currentCell = mazeGrid[y][x]; let moved = false;
            let nextX = x, nextY = y;
            if ((key === 'ArrowUp' || key === 'w') && !currentCell.walls.top) { nextY--; moved = true; }
            else if ((key === 'ArrowDown' || key === 's') && !currentCell.walls.bottom) { nextY++; moved = true; }
            else if ((key === 'ArrowLeft' || key === 'a') && !currentCell.walls.left) { nextX--; moved = true; }
            else if ((key === 'ArrowRight' || key === 'd') && !currentCell.walls.right) { nextX++; moved = true; }
            
            if (moved) {
                state.isAnimating = true; state.playerPos = {x: nextX, y: nextY};
                targetPos.x = nextX * cellSize + cellSize / 2; 
                targetPos.y = nextY * cellSize + cellSize / 2;
                
                const nextCell = mazeGrid[nextY][nextX];
                if(nextCell.decor) {
                    state.collectedDecor++;
                    updateDecorCounter();
                    audioManager.playSfx(config.audio.collectSfx);
                    nextCell.decor = null;
                }

                if (state.gameMode === 'ghost') {
                    state.playerStepCount++;
                    if (state.playerStepCount % 3 === 0) {
                        moveGhost();
                    }
                }
            }
        }

        function moveGhost() {
            const { x, y } = state.ghostPos;
            const moves = [];
            if (y > 0) moves.push({ x: x, y: y - 1 });
            if (y < state.mazeHeight - 1) moves.push({ x: x, y: y + 1 });
            if (x > 0) moves.push({ x: x - 1, y: y });
            if (x < state.mazeWidth - 1) moves.push({ x: x + 1, y: y });

            if (moves.length > 0) {
                state.ghostPos = moves[Math.floor(Math.random() * moves.length)];
            }
        }

        function checkCollision() {
            if (state.playerPos.x === state.ghostPos.x && state.playerPos.y === state.ghostPos.y) {
                if (state.playerIsDefeated) return; 
                state.isGameActive = false;
                state.playerIsDefeated = true;
                state.defeatAnimation.progress = 0;
                state.defeatAnimation.bubbles = [];
                for (let i = 0; i < 15; i++) {
                    state.defeatAnimation.bubbles.push({
                        x: (Math.random() - 0.5) * cellSize * 0.5,
                        y: (Math.random() - 0.5) * cellSize * 0.5,
                        radius: Math.random() * 5,
                        maxRadius: Math.random() * 15 + 10,
                        speed: Math.random() * 0.5 + 0.5,
                    });
                }
                audioManager.playSfx(config.audio.defeatSfx);
                return true;
            }
            return false;
        }
        
        function startGame(levelIndex) {
            state.currentLevel = levelIndex;
            const levelConf = config.levels[levelIndex];
            
            state.playerIsDefeated = false;
            state.collectedDecor = 0;
            state.totalDecor = 0;
            currentBgImage = null;

            const bgChoice = config.backgrounds[Math.floor(Math.random() * config.backgrounds.length)];
            state.wallColor = bgChoice.wallColor;
            
            const bgImage = new Image();
            bgImage.crossOrigin = "Anonymous";
            bgImage.src = bgChoice.src;

            const proceedWithGame = () => {
                if (state.theme === 'random' || !config.themes[state.theme]) {
                    const themeKeys = Object.keys(config.themes);
                    currentTheme = config.themes[themeKeys[Math.floor(Math.random() * themeKeys.length)]];
                } else { currentTheme = config.themes[state.theme]; }
                
                state.mazeWidth = levelConf.w;
                state.mazeHeight = levelConf.h;
                
                const corners = [ {x: 0, y: 0}, {x: state.mazeWidth - 1, y: 0}, {x: 0, y: state.mazeHeight - 1}, {x: state.mazeWidth - 1, y: state.mazeHeight - 1} ];
                state.startPos = { ...corners[Math.floor(Math.random() * corners.length)] };
                state.playerPos = { ...state.startPos };
                
                mazeGrid = generateMaze(state.mazeWidth, state.mazeHeight, state.playerPos);
                state.finishPos = findLongestPath(mazeGrid, mazeGrid[state.playerPos.y][state.playerPos.x]);
                addDecorations(mazeGrid, state.playerPos, state.finishPos, levelConf.bonuses);
                
                if (state.gameMode === 'ghost') {
                    state.playerStepCount = 0;
                    const availableCells = [];
                    for (let y = 0; y < state.mazeHeight; y++) {
                        for (let x = 0; x < state.mazeWidth; x++) {
                            if ((x !== state.playerPos.x || y !== state.playerPos.y) && (x !== state.finishPos.x || y !== state.finishPos.y)) {
                                availableCells.push({x, y});
                            }
                        }
                    }
                    state.ghostPos = availableCells.length > 0 ? availableCells[Math.floor(Math.random() * availableCells.length)] : { x: -1, y: -1 };
                }

                initialMazeGrid = JSON.parse(JSON.stringify(mazeGrid)); 
                updateDecorCounter();

                switchScreen('game-screen');
                setTimeout(() => {
                    const container = document.getElementById('maze-wrapper');
                    if(!container) return;
                    
                    const aspectRatio = state.mazeWidth / state.mazeHeight;
                    const containerRatio = container.clientWidth / container.clientHeight;
                    let mazeW, mazeH;
                    if(containerRatio > aspectRatio) {
                        mazeH = container.clientHeight;
                        mazeW = mazeH * aspectRatio;
                    } else {
                        mazeW = container.clientWidth;
                        mazeH = mazeW / aspectRatio;
                    }

                    cellSize = Math.floor(Math.min(mazeW / state.mazeWidth, mazeH / state.mazeHeight));
                    mazeCanvas.width = cellSize * state.mazeWidth; 
                    mazeCanvas.height = cellSize * state.mazeHeight;

                    displayPos.x = targetPos.x = state.playerPos.x * cellSize + cellSize / 2;
                    displayPos.y = targetPos.y = state.playerPos.y * cellSize + cellSize / 2;
                    stopGameLoop(); 
                    showStartFinish();
                }, 50);
            }

            bgImage.onload = () => {
                currentBgImage = bgImage;
                proceedWithGame();
            };
            bgImage.onerror = () => {
                currentBgImage = null;
                proceedWithGame();
            };
        }
        
        function showStartFinish() { 
            state.isGameActive = false; 
            hintScreenActive = true; 
            
            mazeCtx.clearRect(0, 0, mazeCanvas.width, mazeCanvas.height);
            if (currentBgImage && currentBgImage.complete) {
                mazeCtx.drawImage(currentBgImage, 0, 0, mazeCanvas.width, mazeCanvas.height);
            } else {
                const gradient = mazeCtx.createLinearGradient(0, 0, 0, mazeCanvas.height);
                gradient.addColorStop(0, currentTheme.gradient[0]);
                gradient.addColorStop(1, currentTheme.gradient[1]);
                mazeCtx.fillStyle = gradient;
                mazeCtx.fillRect(0, 0, mazeCanvas.width, mazeCanvas.height);
            }

            drawWalls();
            drawDecor();

            mazeCtx.fillStyle = 'rgba(0, 0, 0, 0.70)';
            mazeCtx.fillRect(0, 0, mazeCanvas.width, mazeCanvas.height);
            
            drawPlayer();
            drawFinish();

            const pointerSize = cellSize * 0.5;
            mazeCtx.font = `${pointerSize}px sans-serif`;
            mazeCtx.textAlign = 'center';
            mazeCtx.textBaseline = 'middle';

            if (state.playerPos.x < state.mazeWidth - 1) {
                mazeCtx.fillText('👈', (state.playerPos.x * cellSize + cellSize / 2) + cellSize * 0.7, state.playerPos.y * cellSize + cellSize / 2);
            }
            if (state.playerPos.x > 0) {
                mazeCtx.fillText('👉', (state.playerPos.x * cellSize + cellSize / 2) - cellSize * 0.7, state.playerPos.y * cellSize + cellSize / 2);
            }
            if (state.finishPos.x < state.mazeWidth - 1) {
                mazeCtx.fillText('👈', (state.finishPos.x * cellSize + cellSize / 2) + cellSize * 0.7, state.finishPos.y * cellSize + cellSize / 2);
            }
            if (state.finishPos.x > 0) {
                mazeCtx.fillText('👉', (state.finishPos.x * cellSize + cellSize / 2) - cellSize * 0.7, state.finishPos.y * cellSize + cellSize / 2);
            }
            
            mazeCanvas.addEventListener('click', beginGameplay, { once: true }); 
            mazeCanvas.addEventListener('touchstart', beginGameplay, { once: true }); 
        }

        function beginGameplay(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            if (!hintScreenActive) return; 
            hintScreenActive = false; 
            state.isGameActive = true; 
            gameLoop();
        }
        function launchConfetti() {
            const container = document.querySelector('#victory-modal .animation-container');
            container.innerHTML = '';
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.left = `${Math.random() * 100}%`;
                confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 70%)`;
                confetti.style.animationDelay = `${Math.random() * 0.5}s`;
                confetti.style.animationDuration = `${Math.random() * 2 + 2}s`;
                container.appendChild(confetti);
            }
        }
        
        function checkWin() { 
            if (state.gameMode === 'ghost' && (state.playerPos.x === state.ghostPos.x && state.playerPos.y === state.ghostPos.y)) {
                return false;
            }

            if (!state.isAnimating && state.playerPos.x === state.finishPos.x && state.playerPos.y === state.finishPos.y) {
                 state.isGameActive = false; 
                 stopGameLoop(); 
                 
                 let stars = 1;
                 if(state.totalDecor > 0) {
                     if (state.collectedDecor === state.totalDecor) { stars = 3; } 
                     else if (state.collectedDecor >= Math.ceil(state.totalDecor / 2)) { stars = 2; }
                 } else { stars = 3; }
                 
                 const currentStars = state.progress[state.gameMode]?.[state.currentLevel] || 0;
                 if (stars > currentStars) {
                     state.progress[state.gameMode][state.currentLevel] = stars;
                     saveProgress();
                     updateTotalStarsCounter();
                 }

                 const starContainer = document.getElementById('star-rating-container');
                 starContainer.innerHTML = '';
                 for(let i=1; i<=3; i++) {
                     const starEl = document.createElement('span');
                     starEl.textContent = '★';
                     starEl.className = i <= stars ? 'star yellow' : 'star gray';
                     starContainer.appendChild(starEl);
                 }

                 const nextLevelButton = document.getElementById('next-level-button');
                 if (state.currentLevel < config.levels.length - 1) {
                     nextLevelButton.style.display = 'flex';
                 } else {
                     nextLevelButton.style.display = 'none';
                 }

                 showModal(victoryModal); 
                 audioManager.playSfx(config.audio.victorySfx[Math.floor(Math.random() * config.audio.victorySfx.length)]); 
                 launchConfetti(); 
                 return true;
            }
            return false;
        }
        
        function showLevelSelectionScreen(mode) {
            state.gameMode = mode;
            const grid = document.getElementById('level-selection-grid');
            grid.innerHTML = '';

            config.levels.forEach((level, index) => {
                const card = document.createElement('button');
                card.className = 'level-card nav-item';
                card.dataset.navIndex = index + 1; 
                
                const starsCount = state.progress[mode]?.[index] || 0;
                let starsHTML = '';
                for(let i = 0; i < 3; i++) {
                    starsHTML += `<span class="star ${i < starsCount ? 'filled' : ''}">★</span>`;
                }

                card.innerHTML = `
                    <div class="level-number">${index + 1}</div>
                    <div class="level-stars">${starsHTML}</div>
                `;
                card.addEventListener('click', () => startGame(index));
                grid.appendChild(card);
            });
            switchScreen('level-selection-screen');
        }

        function showModal(modal) { modal.classList.add('visible'); }
        function hideModal(modal) { modal.classList.remove('visible'); }
        function setLanguage(lang) { 
            state.settings.language = lang; 
            document.documentElement.lang = lang; 
            document.querySelectorAll('[data-lang]').forEach(el => { 
                const key = el.dataset.lang; 
                if (config.languages[lang] && config.languages[lang][key]) { 
                    const span = el.querySelector('span:not(.card-icon)') || el; 
                    span.textContent = config.languages[lang][key]; 
                } 
            }); 
            const dpadKey = state.settings.dpad ? 'dpad_on' : 'dpad_off'; 
            if(document.getElementById('dpad-toggle-button').querySelector('span')) document.getElementById('dpad-toggle-button').querySelector('span').textContent = config.languages[lang][dpadKey]; 
            const soundKey = state.settings.sound ? 'sound_on' : 'sound_off'; 
            if(document.getElementById('sound-toggle-button').querySelector('span')) document.getElementById('sound-toggle-button').querySelector('span').textContent = config.languages[lang][soundKey]; 
            
            const langButtonSpan = document.querySelector('#language-button span:not(.card-icon)');
            if (langButtonSpan) {
                langButtonSpan.textContent = config.languageNames[lang] || lang.toUpperCase();
            }
        }
        
        async function preloadAssets() {
            const imagePromises = config.backgrounds.map(bg => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(`Failed to load image: ${bg.src}`);
                    img.src = bg.src;
                });
            });

            const loaderProgress = document.getElementById('loader-progress');
            const loaderPercentage = document.getElementById('loader-percentage');
            const totalAssets = imagePromises.length;
            
            for(let i=0; i<imagePromises.length; i++) {
                await imagePromises[i];
                const progress = Math.round(((i + 1) / totalAssets) * 100);
                loaderProgress.style.background = `conic-gradient(var(--primary-pink) ${progress * 3.6}deg, #E0E0E0 0%)`;
                loaderPercentage.textContent = `${progress}%`;
            }

            return Promise.all(imagePromises);
        }

        async function initialize() {
            loadProgress();
            updateTotalStarsCounter();

            const userLang = navigator.language.slice(0, 2);
            const defaultLang = config.languages[userLang] ? userLang : 'en';
            setLanguage(defaultLang);

            document.addEventListener('keydown', handleGlobalKeyDown);
            document.addEventListener('visibilitychange', () => audioManager.handleVisibility());
            
            document.getElementById('play-button').addEventListener('click', () => switchScreen('game-mode-screen'));
            document.getElementById('mode-classic').addEventListener('click', () => showLevelSelectionScreen('classic'));
            document.getElementById('mode-flashlight').addEventListener('click', () => showLevelSelectionScreen('flashlight'));
            document.getElementById('mode-ghost').addEventListener('click', () => showLevelSelectionScreen('ghost'));

            document.getElementById('settings-button').addEventListener('click', () => switchScreen('settings-screen'));
            document.getElementById('themes-button').addEventListener('click', () => switchScreen('themes-screen'));
            document.querySelectorAll('.back-button').forEach(btn => btn.addEventListener('click', () => switchScreen(btn.dataset.targetScreen)));
            
            document.getElementById('return-menu-button').addEventListener('click', () => { showModal(confirmExitModal); state.isGameActive = false; });
            document.getElementById('jump-button').addEventListener('click', () => { if (!state.jumpState.active) state.jumpState.active = true; });
            document.getElementById('restart-game-button').addEventListener('click', restartLevel);
            
            // Victory Modal Buttons
            document.getElementById('menu-button-victory').addEventListener('click', () => { hideModal(victoryModal); showLevelSelectionScreen(state.gameMode); });
            document.getElementById('next-level-button').addEventListener('click', () => { hideModal(victoryModal); startGame(state.currentLevel + 1); });
            document.getElementById('retry-level-button-victory').addEventListener('click', restartLevel);
            
            // Confirmation Modals
            document.getElementById('confirm-exit-yes').addEventListener('click', () => { hideModal(confirmExitModal); stopGameLoop(); showLevelSelectionScreen(state.gameMode); });
            document.getElementById('confirm-exit-no').addEventListener('click', () => { hideModal(confirmExitModal); if(!hintScreenActive && !state.playerIsDefeated) state.isGameActive = true; });

            document.getElementById('reset-progress-button').addEventListener('click', () => showModal(confirmResetModal));
            document.getElementById('confirm-reset-yes').addEventListener('click', () => { hideModal(confirmResetModal); resetProgress(); });
            document.getElementById('confirm-reset-no').addEventListener('click', () => hideModal(confirmResetModal));

            const themesPanel = document.querySelector('#themes-screen .menu-panel');
            let themeNavIndex = 2;
            for (const key in config.themes) {
                const theme = config.themes[key];
                const item = document.createElement('button');
                item.className = 'menu-button nav-item'; item.dataset.themeKey = key; item.dataset.navIndex = themeNavIndex++;
                item.innerHTML = `<span class="theme-button-content"><span>${theme.player}</span><span class="theme-name">${theme.name}</span><span>${theme.finish}</span></span>`;
                item.addEventListener('click', () => { state.theme = key; updateEmojiBackground(); switchScreen('main-menu-screen'); });
                themesPanel.appendChild(item);
            }
            document.getElementById('random-theme-button').addEventListener('click', () => { state.theme = 'random'; updateEmojiBackground(); switchScreen('main-menu-screen'); });

            document.getElementById('dpad-toggle-button').addEventListener('click', (e) => { state.settings.dpad = !state.settings.dpad; e.currentTarget.classList.toggle('choice-selected', state.settings.dpad); setLanguage(state.settings.language); document.getElementById('game-screen').classList.toggle('dpad-on', state.settings.dpad);});
            document.getElementById('sound-toggle-button').addEventListener('click', (e) => { state.settings.sound = !state.settings.sound; e.currentTarget.classList.toggle('choice-selected', state.settings.sound); if (!state.settings.sound) { audioManager.stop(); } else if (state.currentScreen !== 'game-screen') { audioManager.play(config.audio.menu, true); } setLanguage(state.settings.language); });
            document.getElementById('language-button').addEventListener('click', () => { const langKeys = Object.keys(config.languages); const nextLang = langKeys[(langKeys.indexOf(state.settings.language) + 1) % langKeys.length]; setLanguage(nextLang); });
            
            const dpadButtons = { 'dpad-up': 'ArrowUp', 'dpad-down': 'ArrowDown', 'dpad-left': 'ArrowLeft', 'dpad-right': 'ArrowRight' };
            for(const [btnId, key] of Object.entries(dpadButtons)) {
                const button = document.getElementById(btnId);
                const startMoving = (e) => { e.preventDefault(); if(moveInterval) clearInterval(moveInterval); handleGameInput(key); moveInterval = setInterval(() => handleGameInput(key), 150); };
                const stopMoving = (e) => { e.preventDefault(); clearInterval(moveInterval); moveInterval = null; };
                button.addEventListener('mousedown', startMoving); button.addEventListener('touchstart', startMoving, { passive: false });
                button.addEventListener('mouseup', stopMoving); button.addEventListener('mouseleave', stopMoving); button.addEventListener('touchend', stopMoving);
            }
            
            mazeCanvas.addEventListener('touchstart', (e) => { if (hintScreenActive) { beginGameplay(e); } else { if (e.touches.length === 1) { touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY; } } }, { passive: false });
            mazeCanvas.addEventListener('touchmove', (e) => { if (e.touches.length === 1) { if (!touchStartX || !touchStartY) return; e.preventDefault(); let dx = e.touches[0].clientX - touchStartX; let dy = e.touches[0].clientY - touchStartY; if (Math.abs(dx) > 20 || Math.abs(dy) > 20) { const key = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 'ArrowRight' : 'ArrowLeft') : (dy > 0 ? 'ArrowDown' : 'ArrowUp'); handleGameInput(key); touchStartX = null; touchStartY = null; } } }, { passive: false });

            try {
                await preloadAssets();
                setTimeout(() => {
                    switchScreen('main-menu-screen');
                    updateEmojiBackground();
                }, 500);
            } catch (error) {
                console.error("Не удалось загрузить изображения, запуск игры со стандартными градиентами.", error);
                config.backgrounds = []; // Очистка, чтобы игра не пыталась использовать незагруженные изображения
                setTimeout(() => {
                    switchScreen('main-menu-screen');
                    updateEmojiBackground();
                }, 500);
            }
            
            const levelScreen = document.getElementById('level-selection-screen');
            levelScreen.prepend(document.getElementById('total-stars-counter-levels'));
        }

        initialize();
    });
    </script>
</body>
</html>
